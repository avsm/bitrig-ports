$OpenBSD: patch-gcc_common_opt,v 1.1 2012/09/01 00:00:32 pascal Exp $
--- gcc/common.opt.orig	Sun Jan 27 19:36:59 2008
+++ gcc/common.opt	Fri Jan 24 23:41:51 2014
@@ -96,6 +96,10 @@ Wlarger-than-
 Common RejectNegative Joined UInteger
 -Wlarger-than-<number>	Warn if an object is larger than <number> bytes
 
+Wstack-larger-than-
+Common RejectNegative Joined UInteger
+-Wstack-larger-than-<number> Warn if a function is using more than <number> bytes of stack space for their local variables.
+
 Wunsafe-loop-optimizations
 Common Var(warn_unsafe_loop_optimizations)
 Warn if the loop cannot be optimized due to nontrivial assumptions.
@@ -153,7 +157,7 @@ Common Var(warn_switch_enum)
 Warn about all enumerated switches missing a specific case
 
 Wsystem-headers
-Common Var(warn_system_headers)
+Common Var(warn_system_headers) Init(1)
 Do not suppress warnings from system headers
 
 Wuninitialized
@@ -188,6 +192,10 @@ Wunused-variable
 Common Var(warn_unused_variable)
 Warn when a variable is unused
 
+Wvariable-decl
+Common Var(warn_variable_decl)
+Warn about variable-sized declarations.
+
 Wvolatile-register-var
 Common Var(warn_register_var)
 Warn when a register variable is declared volatile
@@ -485,7 +493,7 @@ Enable guessing of branch probabilities
 ; On SVR4 targets, it also controls whether or not to emit a
 ; string identifying the compiler.
 fident
-Common Report Var(flag_no_ident,0)
+Common Report Var(flag_no_ident,0) Init(1)
 Process #ident directives
 
 fif-conversion
@@ -668,7 +676,7 @@ Common Report Var(flag_pic,2)
 Generate position-independent code if possible (large mode)
 
 fPIE
-Common Report Var(flag_pie,2)
+Common Report Var(flag_pie,2) Init(PIE_DEFAULT)
 Generate position-independent code for executables if possible (large mode)
 
 fpic
@@ -854,13 +862,17 @@ Common RejectNegative Joined
 -fstack-limit-symbol=<name>	Trap if the stack goes past symbol <name>
 
 fstack-protector
-Common Report Var(flag_stack_protect, 1)
+Common Report Var(flag_stack_protect, 1) Init(-1)
 Use propolice as a stack protection method
 
 fstack-protector-all
 Common Report RejectNegative Var(flag_stack_protect, 2) VarExists
 Use a stack protection method for every function
 
+fstack-protector-strong
+Common Report RejectNegative Var(flag_stack_protect, 3)
+Use a smart stack protection method for certain functions
+
 fstrength-reduce
 Common
 Does nothing.  Preserved for backward compatibility.
@@ -1087,7 +1099,7 @@ Common Report Var(flag_wrapv)
 Assume signed arithmetic overflow wraps around
 
 fzero-initialized-in-bss
-Common Report Var(flag_zero_initialized_in_bss) Init(1)
+Common Report Var(flag_zero_initialized_in_bss) Init(0)
 Put zero initialized data in the bss section
 
 g
